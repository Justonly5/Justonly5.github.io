<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java代理模式]]></title>
    <url>%2F2017%2F12%2F13%2FJava%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java 代理模式代理模式代理，或称 Proxy，一种设计模式，提供了目标对象的另外的访问方式：即通过代理对象访问目标对象。代理的基本原理是使用一个代理将目标对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用转到原始对象上。这样做的好处是可以在目标对象的基础上增强额外的功能操作，即扩展目标对象的功能。 静态代理要求被代理类和代理类同时实现相应的一套接口，通过被代理类的对象调用重写接口的方法时，实际上执行的是被代理类的同样的重写的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface Hello&#123; void say(String msg);&#125;// 目标对象(被代理对象)public class HelloImpl implements Hello&#123; @Override public void say(String msg)&#123; System.out.println("The Target Subject say " + msg); &#125;&#125;// 对 HelloImpl 进行代理。扩展其功能。public class HelloProxy implements Hello&#123; private Hello hello; public HelloProxy(Hello hello)&#123; this.hello = hello; &#125; @Override public void say(String msg)&#123; before(); // 调用被代理对象的方法 hello.say(msg); after(); &#125; // 目标方法扩展 public void before()&#123; System.out.println("Before From Proxy."); &#125; public void after()&#123; System.out.println("After From Proxy."); &#125;&#125;// 测试@Testpublic void testProxy()&#123; // 目标对象 Hello hello = new HelloImpl(); // 代理对象:把目标对象传给代理对象,建立代理关系 Hello helloProxy = new HelloProxy(hello); // 执行代理方法 helloProxy.say("Test Proxy.");&#125; 静态代理总结: 1、可以做到在不修改目标对象的功能前提下，对目标功能扩展。 2、缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多。同时，一旦接口增加方法，目标对象与代理对象都要维护。 PS：个人理解上其实静态代理代理对象与目标对象实现一样的接口这个不是必须的，目的在于保证代理对象和被代理对象有着相同的方法，给调用者一种错觉，调用的是目标对象的方法。 动态代理在程序运行时，根据被代理类及其实现的接口，动态的创建一个代理类。当调用代理类的实现的抽象方式时，就发起对被代理类通用的方法的调用。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。通过使用动态代理，我们可以做一个“统一指示”，对所有代理类的方法进行统一处理，而不用逐一修改每个方法。 涉及的技术点： 1、实现了InvocationHandler 接口的实现类，并重写了invoke()方法 2、Proxy.newInstance(obj.getClass.getClassLoard(),obj.getClass.getInterfaces(),handler) 该方法是在Proxy类中是静态方法，且接收的三个参数依次为： ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的。 Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型。 InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface Subject &#123; void action();&#125;// 被代理类class RealSubject implements Subject &#123; @Override public void action() &#123; System.out.println("我是被代理类，记得要执行我哦！"); &#125;&#125;// 事件处理class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 给被代理的对象实例化 返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; // 当通过代理类的对象发起对被重写的方法的调用时，都会转换为对如下的invoke的方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 前置扩展 before(); // method方法的返回值为returnValue(调用被代理的方法) Object returnValue = method.invoke(this.obj, args); // 后置扩展 after(); return returnValue; &#125; // 目标方法扩展 public void before()&#123; System.out.println("Before From Proxy."); &#125; public void after()&#123; System.out.println("After From Proxy."); &#125;&#125;public class TestProxy &#123; public static void main(String[] args) &#123; // 1.被代理类的对象 RealSubject realSubject = new RealSubject(); // 2.创建一个实现了InvocationHandler接口的类的对象 MyInvocationHandler handler = new MyInvocationHandler(); // 3.调用blind()方法，动态的返回一个同样实现了realSubject所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(realSubject); Subject sub = (Subject) obj;// 此时sub就是代理类的对象 sub.action();// 转到对InvacationHandler接口的实现类的invoke()方法的调用 &#125;&#125; 不管是静态代理还是动态代理，都要求目标对象(被代理对象)是实现了某个接口的对象，如果目标对象没有实现接口，就无法使用动态代理了，并且如果目标对象中新增了接口中没有方法也无法被代理。 Cglibcglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理，也无法代理final 修饰的方法。 定义目标对象(被代理对象) 12345public class TargetObj&#123; public void action()&#123; System.out.println("The Action From Target Object."); &#125;&#125; 实现 MethodInterceptor接口方法intercept，创建代理类 首先导入 cglib 依赖包: 123456&lt;!-- CGLib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132public class CgProxyFactory implements MethodInterceptor&#123; // 目标对象 private Object target; // 初始化目标对象 public CgProxyFactory(Object target)&#123; this.target = target; &#125; public Object getProxyInstance() &#123; // 1. 创建增强器,用来创建动态代理对象 Enhancer enhancer = new Enhancer(); // 2. 为增强器指定要代理的业务类(即为下面生成的代理类的父类) enhancer.setSuperclass(this.target.getClass()); // 3. 设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦截 enhancer.setCallback(this); // 4. 创建动态代理类对象并返回 return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; // Object result = method.invoke(obj, args); // Object result = methodProxy.invoke(obj,args); System.out.println("Do Before Target Action...."); Object result = methodProxy.invokeSuper(obj, args); System.out.println("Do After Target Action...."); return result; &#125;&#125; 测试 1234567@Testpublic void testCgProxy()&#123; TargetObj targetObj = new TargetObj(); CgProxyFactory proxyFactory = new CgProxyFactory(targetObj); TargetObj proxy = (TargetObj)proxyFactory.getProxyInstance(); proxy.action();&#125; 另一种写法: 1234567891011121314151617181920212223242526272829303132public class CgProxyFactory implements MethodInterceptor &#123; private static CgProxyFactory instance = new CgProxyFactory(); private CgProxyFactory()&#123; &#125; public static CgProxyFactory getInstance()&#123; return instance; &#125; public &lt;T&gt; T getProxy(Class&lt;T&gt; cls)&#123; return (T)Enhancer.create(cls,this); &#125; public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("Do Before Target Action...."); Object result = methodProxy.invokeSuper(obj, args); System.out.println("Do After Target Action...."); return result; &#125; // 测试 public static void main(String[] args)&#123; TargetObj proxy = CgProxyFactory.getInstance().getProxy(TargetObj.class); proxy.action(); &#125;&#125;public class TargetObj &#123; public void action()&#123; System.out.println("The Action From Target Object."); &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 学习笔记]]></title>
    <url>%2F2017%2F12%2F04%2FJava-8-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSql 选型]]></title>
    <url>%2F2017%2F12%2F04%2FNoSql-%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[不同的 Nosql，其实应用的场景各有不同，所以我们应该先了解不同 Nosql之间的差别，然后分析什么才是最适合我使用的 Nosql。 一、Nosql 介绍Nosql 的全称是 Not Only Sql，这个概念早起就有人提出，在09年的时候比较火。Nosql 指的是非关系型数据库，而我们常用的都是关系型数据库。就像我们常用的 mysql，sqlserver一样，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql 得到的高速的发展。 二、Nosql 和关系型数据库的区别 存储方式 关系型数据库是表格式的，因此存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便。而 Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。 存储结构 关系型数据库对应的是结构化数据，数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql数据库基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。 存储规范 关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得有点麻烦。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写 存储扩展 这可能是两者之间最大的区别，关系型数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。 查询方式 关系型数据库通过结构化查询语言来操作数据库（就是我们通常说的SQL）。SQL支持数据库CURD操作的功能非常强大，是业界的标准用法。而 Nosql 查询以块为单元操作数据，使用的是非结构化查询语言（UnQl），它是没有标准的。关系型数据库表中主键的概念对应 Nosql 中存储文档的ID。关系型数据库使用预定义优化方式（比如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。 事务 关系型数据库遵循ACID规则（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)），而Nosql数据库遵循BASE原则（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））。由于关系型数据库的数据强一致性，所以对事务的支持很好。关系型数据库支持对事务原子性细粒度控制，并且易于回滚事务。而 Nosql 数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是 Nosq 的闪光点。 性能 关系型数据库为了维护数据的一致性付出了巨大的代价，读写性能比较差。在面对高并发读写性能非常差，面对海量数据的时候效率非常低。而 Nosql 存储的格式都是 key-value 类型的，并且存储在内存中，非常容易存储，而且对于数据的 一致性是 弱要求。Nosql 无需 sql 的解析，提高了读写性能。 授权方式 关系型数据库通常有 SQL Server，Mysql，Oracle。主流的 Nosql 数据库有 redis，memcache，MongoDb。大多数的关系型数据库都是付费的并且价格昂贵，成本较大，而 Nosql 数据库通常都是开源的。 三、Redis、Memcache 和 MongoDb的优缺点Redis 优点 1.支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算） 2.支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失 的手段。 3.支持通过 Replication 进行数据复制，通过 master-slave 机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是 Redis 进行 HA 的重要手段。 4.单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。 5.支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。 6.支持简单的事务需求，但业界使用场景很少，并不成熟。 缺点 1.Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。 2.支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。 3.Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。 Memcache 优点 1.Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。 2.支持直接配置为session handle。 缺点 1.只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。 2.无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。 3.无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。 4.Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。 MongoDB 优点 1.更高的写负载，MongoDB拥有更高的插入速度。 2.处理很大的规模的单表，当数据表太大的时候可以很容易的分割表。 3.高可用性，设置M-S不仅方便而且很快，MongoDB还可以快速、安全及自动化的实现节点（数据中心）故障转移。 4.快速的查询，MongoDB支持二维空间索引，比如管道，因此可以快速及精确的从指定位置获取数据。MongoDB在启动后会将数据库中的数据以文件映射的方式加载到内存中。如果内存资源相当丰富的话，这将极大地提高数据库的查询速度。 5.非结构化数据的爆发增长，增加列在有些情况下可能锁定整个数据库，或者增加负载从而导致性能下降，由于MongoDB的弱数据结构模式，添加1个新字段不会对旧表格有任何影响，整个过程会非常快速。 缺点 1.不支持事务。 2.MongoDB占用空间过大 。 3.MongoDB没有成熟的维护工具。 四、Redis、Memcache和MongoDB的区别 性能 三者的性能都比较高，总的来讲：Memcache和Redis差不多，要高于MongoDB。 便利性 memcache数据结构单一。 redis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数。 mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。 存储空间 redis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）。 memcache可以修改最大可用内存,采用LRU算法。 mongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。 可用性 redis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。 Memcache本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的hash或者环状的算法，解决单点故障引起的抖动问题。 mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。 可靠性 redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响。 memcache不支持，通常用在做缓存,提升性能。 MongoDB从1.8版本开始采用binlog方式支持持久化的可靠性。 一致性 Memcache 在并发场景下，用cas保证一致性。 redis事务支持比较弱，只能保证事务中的每个操作连续执行。 mongoDB不支持事务。 数据分析 mongoDB内置了数据分析的功能(mapreduce),其他两者不支持。 应用场景 redis：数据量较小的更性能操作和运算上。 memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。 MongoDB:主要解决海量数据的访问效率问题。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solr]]></title>
    <url>%2F2017%2F11%2F30%2FSolr%2F</url>
    <content type="text"><![CDATA[Solr一、Solr 是什么Solr 是 Apache下的一个顶级开源项目，采用 Java 开发，它是基于 Lucene 的全文搜索服务器。 Solr 提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。 Solr 是一个全文检索服务器，只需要进行配置就可以实现全文检索服务。 二、Solr 搜索引擎基础 搜索引擎 搜索引擎是指一个庞大的互联网资源数据库，如网页，新闻组，程序，图像等。它有助于在万维网上定位信息。 用户可以通过以关键字或短语的形式将查询传递到搜索引擎中来搜索信息。 搜索引擎然后搜索其数据库并向用户返回相关链接。 搜索引擎组件 一般来说，搜素引擎有三个基本组件，如下所列： Web 爬虫：Web 爬虫也称为蜘蛛或机器人。它是一个收集网络信息的软件组件。 数据库：Web 上的所有信息都存储在数据库中。它们包含大量的 Web 资源。 搜索接口：此组件是用户和数据库之间的接口。它帮助用户搜索数据库。 搜索引擎是如何工作的？ | 步骤 | 标题或名称 | 描述 | | —— | —–: | :—-: | | 1 | 获取原始内容 | 任何搜索应用程序的第一步是收集要进行搜索的目标内容。 | | 2 | 构建文档 | 从原始内容构建文档，让搜索应用程序可以很容易地理解和解释。 | | 3 | 分析文档 | 在索引开始之前，将对文档进行分析。 | | 4 | 索引文档 | 当文档被构建和分析后，下一步是对它们建立索引，以便可以基于特定键而不是文档的全部内容来检索该文档。索引类似于在书开始页或末尾处的目录索引，其中常见单词以其页码显示，使得这些单词可以快速跟踪，而不是搜索整本书。 | | 5 | 用于搜索的用户接口 | 当索引数据库就绪，应用程序可以执行搜索操作。 为了帮助用户进行搜索，应用必须提供用户接口，用户可以在其中输入文本并启动搜索过程。 | |6 |构建查询 |当用户做出搜索文本的请求，应用程序应该使用该文本来准备查询对象，然后可以使用该查询对象来查询索引数据库以获得相关的细节。| |7 |搜索查询|使用查询对象，检查索引数据库以获取相关详细信息和内容文档。| |8 |渲染结果|当收到所需的结果，应用程序应决定如何使用其用户界面向用户显示结果。| 三、Solr 的安装及配置 Linux 环境安装 安装 Tomcat、JDK 123[root@localhost ~]# mkdir /usr/local/solr[root@localhost ~]# cp apache-tomcat-7.0.47 /usr/local/solr/tomcat -r 将 solr 传到 Linux，并解压 把 solr 文件夹下的 /dist/solr-4.10.3.war包部署到tomcat下。并改名为solr.war 1[root@localhost dist]# cp solr-4.10.3.war /usr/local/solr/tomcat/webapps/solr.war 解压war包。启动tomcat自动解压。关闭tomcat。删除solr.war。 123[root@localhost dist]# cd /usr/local/tomcat/bin[root@localhost bin]# ./startup.sh[root@localhost bin]# ./shutdown.sh 把/root/solr-4.10.3/example/lib/ext 目录下所有的jar包复制到solr工程中。 1[root@localhost ext]# cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/ 创建solrhome。Solrhome是存放solr服务器所有配置文件的目录。 123456[root@localhost example]# mkdir /usr/local/solr/solrhome[root@localhost example]# pwd/root/solr-4.10.3/example[root@localhost example]# cp -r solr /usr/local/solr/solrhome[root@localhost example]# 告诉solr服务器solrhome的位置。需要修改solr工程的web.xml文件。 12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/usr/local/solr/solrhome&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 启动 Tomcat，浏览器访问localhost:8080/solr 四、]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2017%2F11%2F30%2FNginx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
